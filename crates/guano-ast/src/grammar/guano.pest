// Comments
line_comment = @{ "##" ~ (!NEWLINE ~ ANY)* ~ NEWLINE? }
block_comment = @{ "#$" ~ ( block_comment | (!"$#" ~ ANY) )* ~ "$#" }

capturing_comment = { line_comment | block_comment }

COMMENT = _{ capturing_comment }

// Whitespace
WHITESPACE = _{ WHITE_SPACE }

// Keywords
keyword = @{ this_keyword | nil_keyword | fun_keyword | 
class_keyword | type_keyword | import_keyword | 
loop_keyword | for_keyword | while_keyword |
in_keyword | break_keyword | continue_keyword |
if_keyword | else_keyword | return_keyword |
as_keyword | veto_keyword | static_keyword |
priv_keyword | boolean_literal_keyword | variable_declaration_keyword |
proto_keyword | boolean_keyword | integer_keyword | unsigned_integer_keyword |
floating_point_keyword | string_keyword | character_keyword }

keyword_end = @{ !( "_" | ASCII_ALPHANUMERIC ) }

this_keyword = @{ "this" ~ keyword_end }
nil_keyword = @{ "nil" ~ keyword_end }
fun_keyword = @{ "fun" ~ keyword_end }
class_keyword = @{ "class" ~ keyword_end }
type_keyword = @{ "type" ~ keyword_end }
import_keyword = @{ "import" ~ keyword_end }
loop_keyword = @{ "loop" ~ keyword_end }
for_keyword = @{ "for" ~ keyword_end }
while_keyword = @{ "while" ~ keyword_end }
in_keyword = @{ "in" ~ keyword_end }
break_keyword = @{ "break" ~ keyword_end }
continue_keyword = @{ "continue" ~ keyword_end }
if_keyword = @{ "if" ~ keyword_end }
else_keyword = @{ "else" ~ keyword_end }
return_keyword = @{ "return" ~ keyword_end }
as_keyword = @{ "as" ~ keyword_end }
veto_keyword = @{ "veto" ~ keyword_end }
static_keyword = @{ "static" ~ keyword_end }
priv_keyword = @{ "priv" ~ keyword_end }
proto_keyword = @{ "proto" ~ keyword_end }
boolean_keyword = @{ "boolean" ~ keyword_end }
integer_keyword = @{ "int" ~ keyword_end }
unsigned_integer_keyword = @{ "uint" ~ keyword_end }
floating_point_keyword = @{ "float" ~ keyword_end }
string_keyword = @{ "string" ~ keyword_end }
character_keyword = @{ "character" ~ keyword_end }

boolean_literal_keyword = { true_keyword | false_keyword }
    true_keyword = @{ "true" ~ keyword_end }
    false_keyword = @{ "false" ~ keyword_end }
variable_declaration_keyword = { let_keyword | var_keyword }
    let_keyword = @{ "let" ~ keyword_end }
    var_keyword = @{ "var" ~ keyword_end }
// Declarations
declaration = { variable_declaration | function_declaration |
                type_alias_declaration | prototype_declaration |
                class_declaration | import_declaration }

    variable_declaration = { variable_declaration_keyword ~ identifier ~
            (
                ( declaration_type ~ variable_declaration_value ) | 
                ( declaration_type ) | ( variable_declaration_value )
            ) ~ ";" }
        declaration_type = { ":" ~ type_ }
        variable_declaration_value = { "=" ~ expression }

    procedure_declaration = { fun_keyword ~ identifier ~ declaration_type? ~ procedure_declaration_parameters? }
    procedure_declaration_parameters = { "@" ~ identifier ~ declaration_type ~ ("," ~ identifier ~ declaration_type)* }

    function_declaration = { procedure_declaration ~ block }

    type_alias_declaration = { type_keyword ~ identifier ~ "=" ~ type_ ~ ";" }

    prototypes = { identifier ~ ( "+" ~ identifier )* }
    prototype_declaration = {
        proto_keyword ~ identifier ~ ( "(" ~ prototypes? ~ ")" )? ~ "{" ~
            ( prototype_method )* ~ 
        "}"
    }
    prototype_method = {
        static_keyword? ~ procedure_declaration ~ ( ";" | block )
    }
    class_declaration = { 
        class_keyword ~ identifier ~ ("(" ~ identifier? ~ ")")? ~ (":" ~ prototypes)? ~ "{" ~ 
            (class_property | class_method)* ~
        "}"
    }
    class_property = { ( static_keyword | priv_keyword )? ~ variable_declaration_keyword ~ identifier ~ declaration_type ~ ";" }
    class_method = { ( static_keyword | priv_keyword )? ~ function_declaration }

    import_declaration = { import_keyword ~ string_literal ~ ( as_keyword ~ identifier )? ~ ";" }



// Statement
statement = { variable_declaration | return_statement | loop_control | 
                infinite_loop | for_loop | while_loop | if_statement | 
                assignment_statement | expression_statement }

    return_statement = { return_keyword ~ expression ~ ";" }
    loop_control = { ( break_keyword | continue_keyword ) ~ ";" }
    infinite_loop = { loop_keyword ~ block }
    for_loop = { for_keyword ~ identifier ~ in_keyword ~ expression ~ block }
    while_loop = { while_keyword ~ expression ~ block }
    if_statement = { if_keyword ~ expression ~ block ~ else_statement? }
    else_statement = { else_keyword ~ (block | if_statement) }
    assignment_statement = { expression ~ assignment_operator ~ expression ~ ";" }
        assignment_operator = { "=" | "+=" | "*=" | "/=" | "%=" | "-=" | "^=" | "&=" | "|=" | "<<=" | ">>=" | "&&=" | "||=" }
    expression_statement = { expression ~ ";" }

// Block
block = { "{" ~ ( statement | block | ";" )* ~ "}" }

// Identifier
identifier = @{ !keyword ~ (("_" | ASCII_ALPHA) ~ ("_" | ASCII_ALPHANUMERIC)* ) }

// Type
type_ = { function_type | list_type | tuple_type | primitive_type | custom_type }
    // Primitive
    primitive_type = { boolean_type | integer_type | 
                    unsigned_integer_type | floating_point_type | 
                    string_type | character_type }

        boolean_type = { boolean_keyword }
        integer_type = { integer_keyword }
        unsigned_integer_type = { unsigned_integer_keyword }
        floating_point_type = { floating_point_keyword }
        string_type = { string_keyword }
        character_type = { character_keyword }
        custom_type = { identifier }
        list_type = { "[]" ~ type_ }
        tuple_type = { "(" ~ tuple_type_inner? ~ ")"}
        tuple_type_inner = { type_ ~ ("," ~ type_)* }
        function_type = { fun_keyword ~ ("(" ~ ( type_ ~ ( "," ~ type_)* )? ~ ")")? ~ declaration_type? }


// Expression
expression = { prefix* ~ primary ~ postfix* ~ ( infix ~ prefix* ~ primary ~ postfix* )* }
    // prefix
    prefix = _{ negate | not }
        negate = { "-" }
        not = { "!" }
    // infix
    infix = _{ factor | term | bitwise | relational | logical }
        factor = { mul | div | modu }
            mul = { "*" }
            div = { "/" }
            modu = { "%" }
        term = { add | sub }
            add = { "+" }
            sub = { "-" }
        bitwise = { bitshift_left | bitshift_right | bitwise_xor | bitwise_and | bitwise_or  }
            bitshift_left = { "<<" }
            bitshift_right = { ">>" }
            bitwise_xor = { "^" }
            bitwise_and = { !logical_and ~ "&" }
            bitwise_or = { !logical_or ~ "|" }
        relational = { greater_than_eq | greater_than | less_than_eq | less_than | equals | not_equals }
            greater_than = { ">" }
            greater_than_eq = { ">=" }
            less_than = { "<" }
            less_than_eq = { "<=" }
            equals = { "==" }
            not_equals = { "!=" }
        logical = { logical_and | logical_or }
            logical_and = { "&&" }
            logical_or = { "||" }
    // postfix
    postfix = _{ index | call | property | cast }
        call = { "(" ~ list_inner? ~ ")" }
        index = { "[" ~ expression ~ "]" }
        property = { "." ~ identifier }
        cast = { as_keyword ~ type_ }
    // Primary expressions
    primary = _{ this_keyword | identifier | literal | grouped }
        // Literals
        literal = { nil_literal | boolean_literal | number_literal | text_literal | collection_literal }
            boolean_literal = { boolean_literal_keyword }
            nil_literal = { nil_keyword }
            // Numeric (integer and float) literals
            number_literal = { floating_point | integer }
                integer = { binary_integer | hexadecial_integer | decimal_integer }
                    binary_integer = @{ "0b" ~ ASCII_BIN_DIGIT ~ (ASCII_BIN_DIGIT | "_")* }
                    hexadecial_integer = @{ "0x" ~ ASCII_HEX_DIGIT ~ (ASCII_HEX_DIGIT | "_")* }
                    decimal_integer = @{ (ASCII_NONZERO_DIGIT ~ (ASCII_DIGIT | "_")*) | ASCII_DIGIT }
                    // TODO: Octals
                floating_point = @{ decimal_integer ~ "." ~ decimal_integer }
            // String and character literals
            text_literal = { format_string | string_literal | character_literal }
                text_inner = ${ single_escape | ascii_escape | unicode_escape | (!"\\" ~ ANY) }
                    single_escape = @{ "\\" ~ ("t" | "r" | "n" | "0" | "\\" | "'" | "\"") }
                    ascii_escape = @{ "\\x" ~ ASCII_HEX_DIGIT{2} }
                    unicode_escape = @{ little_unicode_escape | big_unicode_escape }
                        big_unicode_escape = @{ "\\U" ~ ASCII_HEX_DIGIT{8} }
                        little_unicode_escape = @{ "\\u" ~ ASCII_HEX_DIGIT{4} }
                string_literal = ${ "\"" ~ (!("\"" | NEWLINE) ~ text_inner)* ~ "\"" }
                format_string = { string_literal ~ ":" ~ expression }
                character_literal = ${ "'" ~ (!("'" | NEWLINE) ~ text_inner) ~ "'" }
            // Collection literals
            collection_literal = { list_literal | tuple_literal }
                // Tuple
                tuple_inner = { ( expression ~ ("," ~ expression)+ ) | ( expression ~ "," ) }
                tuple_literal = { "(" ~ tuple_inner? ~ ")" }
                // List
                list_inner = { expression ~ ("," ~ expression)* }
                list_literal = { "[" ~ list_inner? ~ "]" }
        // Grouped
        grouped = { "(" ~ expression ~ ")" }

// Source file
source_file = {
    SOI ~
    declaration* ~
    EOI
}